//Name : yuhang lian
//PID  : A91018743


/**
 * ALL FUNCTION IMPLEMENTATIONS AND HELPER FUNCTIONS FOR ENCODER WILL BE IN THIS FILE.
 */

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include "common.h"
#include "encoder.h"




    
/**
 *
 * This function takes a char c as input and returns a (6 character) array
 * that represents the 6 digit code for that character. This code is simply
 * the index of the char in the MAPPING array (represented in binary). 
 * You should use the REVERSE\_MAPPING array in this function to get 
 * the binary code for the character. REVERSE\_MAPPING array MUST be 
 * initialized with createReverseMapping(), prior to calling this function.
 *
 * @param c The input character to encode
 * @returns a six character array which encodes the index into ASCII binary
 */
char* encodeChar(char c){
    // TODO Implement me!
    char* returnArr;
    returnArr = calloc(sizeof(char),6); // CREATE THE ARRAY
    int returnVal = REVERSE_MAPPING[c];
    int n, d, k;
    int index = 0;//COUNT EACH BIT
    for (d = 5; d >= 0; d--)
    {//WRITE THEM IN
        k = returnVal >> d;
        if (k & 1){
            returnArr[index] = 1;
            index++;
        }
        else{
            returnArr[index] = 0;
            index++;
        }
    }
    
    return returnArr;
}

/**
 * Takes a char c and int bit (should be either 0 or 1) and int index as input. 
 * Sets the bit at input index of c to be the input bit and returns the result.
 * The 0 index refers to the LSB, so for example, index 2 should 
 * set the 3rd least significant bit.
 * 
 * @param c the char to implant a bit into
 * @param bit the bit value to implant (0 or 1)
 * @param index the index to implant the bit into (0 is LSB)
 * @returns the char with bit b implanted into the input index
 */
char implantBit(char c, int bit, int index){
    // TODO Implement me!
    char in  = c >> index;
    char comp = in >>1;
    comp = comp << 1;
    int target = in - comp;
    if(target == bit){
        return c;
    }//CHECK THE VALUE OF THE INPUT AND PUT BIT IN POSITION
    else if(target == 1){
        char val = c >> index;
        val = val << index;
        char store = c - val;
        c = c >> (index + 1);
        c = c << (index + 1);
        c = c + store;
        return c;
    }//DO THE SAME IF THE TARGET IS 0
    else if(target == 0){
        char val = c >> index;
        val = val << index;
        char store = c - val;
        c = c >> (index +1);
        c = c << 1;
        c++;
        c = c << index;
        c = c + store;
        return c;
    }
    return c;
}

/**
 * Takes a FILE handle in as input (corresponding to a regular ASCII
 * text file) and reads the file, char by char. Encodes each char into
 * a 6 character "binary" char array (by calling encodeChar).  The
 * resulting character arrays should be written to the output file
 * handle out
 *
 * @param in The input text file to read
 * @param out The output file, in ASCII encoded "binary"
 */
void textToBinary(FILE *in, FILE *out){
    // TODO Implement me!
    while(!feof(in)){
        char inC = fgetc(in);
        char* result = encodeChar(inC);//CALL ENCODE CHAR
        if(feof(in)){
            return;
        }//IF REACHED THE END , JUST RETURN
        for(int i = 0; i < 6; i++){
            fprintf(out,"%d",result[i]);
        }
    }
}

/**
 * Takes a FILE handle in as input (corresponding to a
 * "binary" encoded file) and reads the file 1 char at a time. Each
 * char read will be an ASCII '0' or ASCII '1', and either 0 or 1 
 * will be implanted into randomized chars generated by rand()%256.
 *
 * If ASCII '0', then implant 0 into the bit at the input index 
 * of a randomized char . If ASCII '1', then implant 1 into the bit at 
 * the input index of the randomized char (by calling implantBit). 
 * Write the result into the output file handle out 
 * (Note: The least significant bit is in index 0)
 *
 * @param in The input file handle to read (ASCII encoded binary)
 * @param out The output file to write to
 * @param index the index of the bit where binary values should be implanted (0 is LSB)
 */

void binaryToCode(FILE *in, FILE *out, int index){
    srand(1); //DO NOT REMOVE OR EDIT THIS LINE OF CODE
    // TODO Implement me!
    while(!feof(in)){
        char outC = rand()%256; // GET THE RANDOM CHAR
        char inC = fgetc(in);
        if(inC == '1'){
            outC = implantBit(outC,1,index);
            fputc(outC,out);//WIRTE THE CHAR IN TO FILE
        }
        else if(inC == '0'){
            outC = implantBit(outC,0,index); // IMPLANT BIT
            fputc(outC,out);
        }
    }
}

/**
 * Reads in a file from the specified input path and outputs a a binary encoding to
 * specified bin path and a fully encoded version to specified output path. 
 * This should simply open the necessary files and call the above helper 
 * functions in the correct sequence, and close the necessary files.
 *
 * @param input the path to the input file
 * @param bin the path to the encoded ASCII binary output file
 * @param output the path to the encoded output file 
 * @param index The index of the bit where binary values should be implanted (0 is LSB)
*/
void encodeFile(char* input, char* bin, char* output, int index){
    // TODO Implement me!
    FILE* in = fopen(input,"r");
    FILE* out = fopen(bin,"w");
    textToBinary(in,out);
    fclose(in);
    fclose(out);//CREATE 2 FILE AND THEN OUT PUT;
    FILE* in2 = fopen(bin,"r");
    FILE* out2= fopen(output,"w");
    binaryToCode(in2,out2,index);
    fclose(in2);
    fclose(out2);
}
